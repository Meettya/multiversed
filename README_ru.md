# Multiversed

**Multiversed** - инструмент для создания версионного API в пределах одной кодовой базы.

Можете рассматривать его как некий аналог GitHub в runtime - указанием целевого продукта и версии прозрачно меняется как само API, так и его реализация.

Причина создания - необходимость иметь возможность реализовывать произвольное подмножество API, сохраняя единую кодовую базу, с автоматизацией построения функционала требуемой конфигурации, наследованием функционала и его переопределением.

## Как с этим работать

### Минимальный пример

Минимальный пример для демонстрации как с этим работать:

```
Multiversed = require 'multiversed'
ImplementationDirectory = 'implementation_dir' # полный путь к директории с реализациями API

# создаем фабрику
multiversed_cb = new Multiversed

# инициируем ее с использованием коллбека (так же есть EventEmmiter интерфейс)
multiversed_cb.initFactory ImplementationDirectory, (err, factory) ->

  # наше целевое API строится для данного продукта с определенной версией
  product  = 'product_b'
  version  = '0.0.5'

  # разрешаем интерфейс для нужной нам версии
  interface_api = factory.buildInterface product, version

  # и теперь можем выполнять какие-то действия с полученным интерфейсом
  result = interface_api.executeSync 'get_version', 'Just prefix'

  console.log result # -> Just prefix - 0.0.5

```
Дополнительно смотри `examples/01_base_example`.

### Пример подробнее

Профит был как-то не очевиден, но давайте расширим пример, переписав коллбек инициации:
```
# инициируем ее с использованием коллбека (так же есть EventEmmiter интерфейс)
multiversed_cb.initFactory ImplementationDirectory, (err, factory) ->

  product  = 'product_b'

  test_steps = [
    '0.0.3'
    '0.0.4'
    '0.0.5'
    '0.0.6'
    '0.0.7'
    '0.0.8'
  ]

  for version, idx in test_steps

    interface_api = factory.buildInterface product, version
    # используем "ленивый" стиль вызова - отсутствие реализации не вызывает выброса исключения,
    # в production коде лучше предварительно использовать проверку interface_api.isCommandExists 'get_version'
    result = interface_api.executeSync true, 'get_version', 'Just prefix'

    console.log "#{idx+1}) result for product |#{product}| with version |#{version}| - |#{result}|"

```
Дополнительно смотри `examples/02_full_example`.

Теперь в консоли будет вывод немного поинтереснее:
```
1) result for product |product_b| with version |0.0.3| - |undefined|
2) result for product |product_b| with version |0.0.4| - |Unprefixed  - 0.0.4|
3) result for product |product_b| with version |0.0.5| - |Just prefix - 0.0.5|
4) result for product |product_b| with version |0.0.6| - |Just prefix - 0.0.6|
5) result for product |product_b| with version |0.0.7| - |Just prefix - 0.0.6|
6) result for product |product_b| with version |0.0.8| - |Unprefixed  - 0.0.8|
```
для реализаций (полный код реализаций смотри `test/fixtures/product_b`):
```
#v0.0.3 - отсутствует
# при использовании нормального (не ленивого) запроса выполнения команды
# для нереализованного API произойдет выброс исключения

#v0.0.4
# определяется в первый раз
get_version = ->
  "Unprefixed  - #{@version}"

#v0.0.5
# переопределяется на месте
get_version = (prefix) ->
  "#{prefix} - #{@version}"

#v0.0.6
# наследуется из v0.0.5 по умолчанию

#v0.0.7 - отсутствует
# наследуется из v0.0.6 по умолчанию, в том числе и значение version

#v0.0.8
# переопределяется с загрузкой из более старой реализации
{ get_version } = require './v0.0.4'
```
## А где профит-то?

**Multiversed** предоставляет ряд неочевидных плюсов:

### Преимущества перед чистой "конфигурацией"

  - позволяет создавать файлы реализации только если имеются версионные изменения, самостоятельно реализуя промежуточные и старшие версии
  - позволяет вынести логику переключений реализации из основной логики программы - в случае чистой "конфигурации" есть вероятность появления раскидистой схемы состояний
  - позволяет "ответвлять" реализацию интерфейсов - очень полезно при наличии деплоя нескольких релизных веток (положим мы выпустили что-то версии v.2.0.1 но обязаны так же поддерживать v1.84.1718, где со временем появятся какие-то решения, не имеющие смысла в ветке v2)

### Преимущества перед наследованием

  - реализует плоский одноуровневый объект из версионной структуры любого размера - при наличии ОЧЕНЬ большой структуры время будет потрачено только единожды на сборку (что в дальнейшем будет оптимизировано дополнительно), при классическом наследовании глубокое вложение объектов черевато проблемами
  - реализует плоский одноуровневый объект, гарантировано за O(1) предоставляя реализацию метода или сообщая об его отсутствии - в классическом "глубоком" наследовании "method missing" может оказаться довольно дорогим
  - позволяет скомпоновать интерфейс из любого, неограниченного количества источников, нет проблемы "хрупкости базового класса"
  - позволяет переопределить реализацию, используя определение любой удаленности, в наследовании вернуть поведение "пра-пра-деда", переопределенное в предках - практически невозможно

### Преимущества перед миксинами

  - миксины позволяют гибко реализовывать объекты, комбинируя требуемые методы, однако не предоставляют возможности прозрачного переопределения методов, требуя описания схемы состояний

И ряд неочевидных минусов:

### Недостатки использования Multiversed

 - требуется строго придерживаться правила - реализация только в соответствующих классах, в версионных файлах - только вызов этих методов (в противном случае нарушаются все SOLID-принципы особенно если инструмент попустительствует этому)
 - неочевидность реализации (по сравнению с классическими схемами)
 - усложняется отладка (правда использование встроенных инструментов должно помочь)

## Все равно не уверен что мне это нужно

Вероятнее всего так оно и есть - у данного инструмента очень специфичный кейс использования. **Multiversed** был написан не от хорошей жизни и призван решить проблему "как сделать матрицу продуктов M*N, сохранив единую кодовую базу".

**Multiversed** поможет в случае, если у вас есть несовместимые релизы, в рамках которых обновляются минорные версии или если ваш сервис является посредником между рядом поставщиков данных и потребителей данных, которые вы не контролируете, или если у вас есть все это сразу и все активно развивается и меняется - в общем если у вас есть реально большая неконтролируемая проблема, ради решения которой вы готовы терпеть контролируемую проблему средних размеров.

Короче - **multiversed** чертовски горькое лекарство с кучей побочных эффектов, но альтернатива еще хуже - пила хирурга.

## Ok, show me the code

Цикл работы с **multiversed** разделен на 2 части - взаимодействие с фабрикой интерфейсов и с реализацией исполнителя API, построенного фабрикой.

Необходимые пояснения о самих файлах версий будут так же приведены далее по тексту.

### Factory API

Сама фабрика реализует только конструктор и 2 метода

#### #new(options)
```
@param {Object}    options     параметры конструктора
```
```
multiversed = new Multiversed 
```
Конструктор принимает в качестве параметров объект:

 - `logger` - реализация объекта логгирования, по умолчанию `console` (DI в чистом виде, переданный объект должен реализовывать API `console`)
 - `strict` - флаг строгого режима, если он установлен - отклонения, которые могут является ошибками-опечатками (в каталогах и т.д.) - обязательно кидают ошибку (пока толком не реализовано)

#### #initFactory(dir [, cb])
```
@param {String}    dir     целевая директория
@param {Function}  cb      (optional) callback
```

```
# using callback
multiversed.initFactory 'some_dir', (err, factory) ->
  onFactoryReady factory

# or using EventEmmiter
multiversed.on 'ready', (factory) -> 
  onFactoryReady factory
multiversed.initFactory 'some_dir'
```

Да, можно использовать любой стиль обращения для инициации фабрики, путь к директории должен быть полным.

Инициировать фабрику можно только единожды (возможно это поведение будет изменено в будущем)

#### #buildInterface(product, version)
```
@param {String}   product   наименование продукта
@param {String}   version   целевая версия системы
```


```
onFactoryReady = (factory) ->
  interfaceObject = factory.buildInterface 'awesome_product', 'v2.0.3-beta'
```

Требует указания продукта и версии:

  - `product` - в директории `some_dir` должна существовать поддиректория `awesome_product`
  - `version` - любая, валидная с точки semver, версия для которой требуется построить API

Если несоответствие `product` вызовет исключение, то указание несуществующей версии даст или реализацию ближайшей меньшей версии (не забывайте, что с точки зрения semver бета-версия ниже обычной 0.0.4 < 0.0.5-rc1 < 0.0.5 ) или вернет пустую реализацию - API будет построен, но он ничего нее умеет.

Строить интерфейсы можно сколько угодно раз.

### Executor API

Фабрика возвращает объект, инкапсулирующий внутри себя построенное API и некоторые служебные методы

#### #execute([is_lenient,] command [, args...], cb)
```
@params {Boolean}   is_lenient  (optional)  опциональный ключ - если false или отсутствует - выкинет ошибку на неизвестную команду, если true - просто undefined
@params {String}    command                 команда
@params {Any}       args        (optional)  аргументы
@params {Function}  cb                      calback
```
```
interfaceObject.execute 'some_command', (err, result) ->
```

Асинхронно выполняет указанную команду, возвращая результат в коллбек (при отсутствии колбека будет выброшено исключение), может принимать произвольное число аргументов и опциональный флаг "ленивого режима".

Нужно понимать, что сама команда должна быть реализована с учетом асинхронного обращения к ней, иначе вы можете получить странный результат.

#### #executeSync([is_lenient,] command [, args...])
```
@params {Boolean}   is_lenient  (optional)  опциональный ключ - если false или отсутствует - выкинет ошибку на неизвестную команду, если true - просто undefined
@params {String}    command                 команда
@params {Any}       args        (optional)  аргументы
```
```
result = interfaceObject.executeSync 'some_sync_command', arg_1, arg_2
```

Синхронно выполняет указанную команду, возвращая результат, может принимать произвольное число аргументов и опциональный флаг "ленивого режима".

Нужно понимать, что сама команда должна быть синхронной, синхронное выполнение асинхронной команды API скорее всего даст вам странный результат.

#### #isCommandExists(command)
```
@params {String} command  имя команды для проверки
```
```
if interfaceObject.isCommandExists 'some_command'
  interfaceObject.execute 'some_command', (err, result) ->
```

Проверяет существует ли такая команда, предпочтительнее использовать данный метод проверки реализованного интерфейса.

В основном используется _вне_ объекта API, но может быть использовано и внутри.

#### #getRuntimeEnvValue(key)
```
@params {String} key ключ по которому нужен параметр
@return {Mixed}
```
```
some_param_value = interfaceObject.getRuntimeEnvValue 'some_param'
```

Возвращает значение для одного параметра из окружения среды исполнения команды. 

В основном используется _внутри_ объекта API, но может быть использовано и вне.

#### #getRuntimeEnv(keys...)
```
@params {Mixed} keys ключ/список ключей/массив со списком ключей
@return {Object}
```
```
some_params = interfaceObject.getRuntimeEnv 'some_param', 'another_param'
###
some_params = 
  some_param    : 'value'
  another_param : 'value_2'
###
```

Возвращает объект с параметрами из окружения среды исполнения команды.

В основном используется _внутри_ объекта API, но может быть использовано и вне.

#### #setRuntimeEnv(env_object)
```
@param {Object} env_object объект со свойствами среды исполнения 
```
```
interfaceObject.setRuntimeEnv new_param : 'value_3'
```

Устанавливает (дополняет или перезаписывает) окружение среды исполнения команды.

В основном используется _вне_ объекта API, но может быть использовано и внутри.

#### #whereResolved(command)
```
@params {String} command  имя команды для проверки
```
```
console.log interfaceObject.whereResolved 'some_command'
```
Сообщает в какой версии была разрешена (определена) команда.

Крайне полезно для тестов и отладки.

#### #getFullResolvedList()
```
console.log interfaceObject.getFullResolvedList()
```
Возвращает полный список команд с версией, в которой они были разрешены (определены).

Крайне полезно для тестов и отладки.

### Файл версии

#### Базовый функционал

Функционально файл версии работает практически так же, как стандартный модуль node.js - запрашивает дополнительный функционал через `require` и экспортирует функции при помощи объекта `module.exports`.

Специфика файлов версий заключена в том, что контекст исполнения (ака `this`) присваивается результирующему объединенному объекту, т.е. можно сделать как-то так:
```
# v0.0.4
module.exports = 
  _element_count_ : 10

# v0.0.5
module.exports = 
  get_elements_count : -> @_element_count_
```
Верно, данные так же требуется экспортировать, но доступ к ним возможен только внутри модулей версий, API исполнителя не предоставляет такой возможности (потому что это плохая практика). Если данные все же нужны - создайте функцию-обертку для их получения.

Аналогичным образом можно получить доступ к другим функциям, объявленным в родительских модулях:
```
# v0.0.6
module.exports = 
  multiple_elements_count_by : (number) ->
    @get_elements_count() * number
```

#### Примеси

Кроме этого в итоговую реализацию подмешиваются функции исполнителя, для возможности иметь к ним доступ _внутри_ самого модуля, вот их список:
```
  getRuntimeEnv
  getRuntimeEnvValue
  setRuntimeEnv
  isCommandExists
```
Перечисленные методы являются зарезервированными словами, их использование в файлах конфигурации вызовет ошибку.

Применять их можно сделать как-то так:
```
# v0.0.8
available_test = ->
  'existing method'     : @isCommandExists 'multiple_elements_count_by'
  'non-existing method' : @isCommandExists 'sdkjgskdjgdskgdskj'

module.exports = 
  { available_test }
```
и при вызове (API версии v0.0.8) получить 
```
{ 'existing method': true, 'non-existing method': false }
```

##### RuntimeEnv

Группа методов `*RuntimeEnv*` была введена для прозрачного доступа к реестру переменных среды исполнения, именного его (реестр) следует использовать для передачи API объектов типа "соединение с БД" (или пулл), "файл конфигурации" и т.п. общих ресурсов.

## Если что-то непонятно

Модуль поставляется с каталогом `example` для подробного изучения на примерах и каталогом `test`, который фактически описывает спецификацию продукта. 

## Я нашел ошибку или не хватает функционала

Смело открывайте issue, так вы поможете улучшить код и документацию.

## Хочу помочь с переводом документации

Просто отлично! Сделайте, пожалуйста, fork и merge request с переводом, не забыв указать себя в разделе **Благодарности** :)

Ну, если забудете - я обязательно сделаю это сам.

## Лицензия 

Модуль предоставляется под лицензией [MIT (Expat)](https://raw.github.com/Meettya/multiversed/master/LICENSE).
