// Generated by CoffeeScript 1.8.0

/*
Фабрика для получения объекта с набором методов.

Выглядеть результат будет как объект, реализующий доступный интерфейс 
для указанной версии указанного целевого продука

Причем для ускорения процесса определения доступности методов и избавления от глубокой цепи наследования
решили реализовывать в Java-стиле "делатель(давай-давай)".

А API оформляется плоским объектом в версиях и собирается мерджем снизу вверх,
для отсутствующих методов делаем заглушки not_implemented,
кроме того могут быть deprecated и removed - если уж совсем метод неверный

Reason d`etre - когда клиентов (пользоватлей компонента) и поставщиков (компонентов, предоставляющих данные)
становится много - нужно или делать кучу отдельных веток кода или делать компановщик
 */

(function() {
  var BaseExecutor, ComponentFactory, EventEmitter, ProductsStack, async, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('lodash');

  async = require('async');

  EventEmitter = require('events').EventEmitter;

  ProductsStack = require('./products_stack');

  BaseExecutor = require('./base_executor');

  module.exports = ComponentFactory = (function(_super) {
    __extends(ComponentFactory, _super);

    function ComponentFactory(options) {
      var _ref, _ref1;
      if (options == null) {
        options = {};
      }
      this._checkArgs = __bind(this._checkArgs, this);
      this._buildInterface = __bind(this._buildInterface, this);
      this._getStepsImplementations = __bind(this._getStepsImplementations, this);
      this._resultHubBuilder = __bind(this._resultHubBuilder, this);
      this._initFactory = __bind(this._initFactory, this);
      this.buildInterface = __bind(this.buildInterface, this);
      this.initFactory = __bind(this.initFactory, this);
      this._logger_ = (_ref = options.logger) != null ? _ref : console;
      this._is_strict_ = (_ref1 = options.strict) != null ? _ref1 : false;
      this._is_inited_ = false;
      this._products_stack_ = new ProductsStack({
        logger: this._logger_,
        strict: this._is_strict_
      });
    }


    /*
    Нам нужна асинхронная инициация объекта
    Как вариант - отправляем запрос на инициацию, предварительно создав слушателя
    
    @param {String}    dir     целевая директория
    @param {Function}  cb      (optional) callback
     */

    ComponentFactory.prototype.initFactory = function(dir, cb) {
      return this._initFactory(dir, this._resultHubBuilder(cb));
    };


    /*
    Этот метод строит нам интерфейс к источнику данных, соответствующий запрошенному продукту и версии
    
    @param {String}   product   наименование продукта
    @param {String}   version   целевая версия системы
     */

    ComponentFactory.prototype.buildInterface = function(product, version) {
      return this._buildInterface(product, version);
    };


    /*  
          ******  ******  *** *     *    *    ******* ******* 
          *     * *     *  *  *     *   * *      *    *       
          *     * *     *  *  *     *  *   *     *    *       
          ******  ******   *  *     * *     *    *    *****   
          *       *   *    *   *   *  *******    *    *       
          *       *    *   *    * *   *     *    *    *       
          *       *     * ***    *    *     *    *    *******
     */


    /*
    По сути инициировать нужно только ProductsStack,
    все остальное потом будет разрешаться относительно него
     */

    ComponentFactory.prototype._initFactory = function(dir, hub) {
      if (this._is_inited_) {
        return hub('error', Error("already inited with dir |" + this._current_dir_ + "|, abort!"));
      }
      if (!_.isString(dir)) {
        return hub('error', Error("must be called with valid directory, but get |" + dir + "|"));
      }
      this._is_inited_ = true;
      this._current_dir_ = dir;
      return this._products_stack_.initStack(dir, (function(_this) {
        return function(err, stack) {
          if (err != null) {
            return hub('error', err);
          }
          return hub('ok', _this);
        };
      })(this));
    };


    /*
    Это билдер хаба для возврата клиенту результата асинхронной операции
    идея в том, что у нас может быть коллбек или слушатели или и то и другое
     */

    ComponentFactory.prototype._resultHubBuilder = function(cb) {
      var cb_step, listeners_step, steps, _ref;
      _ref = this._getStepsImplementations(cb), cb_step = _ref.cb_step, listeners_step = _ref.listeners_step;
      steps = [listeners_step];
      if (_.isFunction(cb)) {
        steps.push(cb_step);
      } else if (_.isEmpty(this.listeners('ready'))) {
        this._logger_.warn("nobody care about inited factory, is it ok?");
      }
      if (_.isFunction(cb) && _.isEmpty(this.listeners('error'))) {
        this.on('error', (function(_this) {
          return function(err) {
            return _this._logger_.warn(err);
          };
        })(this));
      }
      return function(state, data) {
        var step, _i, _len;
        for (_i = 0, _len = steps.length; _i < _len; _i++) {
          step = steps[_i];
          step(state, data);
        }
        return null;
      };
    };


    /*
    Возвращает реализации шагов
     */

    ComponentFactory.prototype._getStepsImplementations = function(cb) {
      var unknown_state_err;
      unknown_state_err = function(state) {
        throw Error("unknown state |" + state + "|");
      };
      return {
        cb_step: function(state, data) {
          switch (state) {
            case 'error':
              return cb(data);
            case 'ok':
              return cb(null, data);
            default:
              return unknown_state_err(state);
          }
        },
        listeners_step: (function(_this) {
          return function(state, data) {
            switch (state) {
              case 'error':
                return _this.emit('error', data);
              case 'ok':
                return _this.emit('ready', data);
              default:
                return unknown_state_err(state);
            }
          };
        })(this)
      };
    };


    /*
    Просто запросим это у стека продуктов и завернем в исполнитель
     */

    ComponentFactory.prototype._buildInterface = function(product, version) {
      var raw_interface;
      if (!this._is_inited_) {
        throw Error("init object first, aborted!");
      }
      if (this._checkArgs(product, version)) {
        raw_interface = this._products_stack_.getProduct(product).buildVersion(version);
        return new BaseExecutor(raw_interface, {
          logger: this._logger_,
          strict: this._is_strict_
        });
      }
    };


    /*
    Если что-то не указано - ничего не делаем ни в коем случае!
    TODO @meettya не нравится, подумать
     */

    ComponentFactory.prototype._checkArgs = function(product, version) {
      var get_error_text;
      get_error_text = function(name, value) {
        return "" + name + " MUST be specified, but get |" + value + "|, abort!";
      };
      if (!product) {
        throw Error(get_error_text('product', product));
      }
      if (!version) {
        throw Error(get_error_text('version', version));
      }
      return true;
    };

    return ComponentFactory;

  })(EventEmitter);

}).call(this);
