// Generated by CoffeeScript 1.8.0

/*

Это базовый клас исполнителя команд - его мы по факту возвращаем из фабрики

он инкапсулирует в себе несколько методов, которые выполняют всю работу на верхнем уровне абстракции
 */

(function() {
  var BaseExecutor, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  _ = require('lodash');

  module.exports = BaseExecutor = (function() {

    /*
    @param {Object} {logger} - logger-объект
     */
    function BaseExecutor(in_command_object, options) {
      var _ref, _ref1;
      if (options == null) {
        options = {};
      }
      this._isCommandExists = __bind(this._isCommandExists, this);
      this._unknownCommandErrorString = __bind(this._unknownCommandErrorString, this);
      this._executeCommandSync = __bind(this._executeCommandSync, this);
      this._executeCommand = __bind(this._executeCommand, this);
      this._getReservedIdentifiersErrorText = __bind(this._getReservedIdentifiersErrorText, this);
      this._processInCommandObject = __bind(this._processInCommandObject, this);
      this._buildExecutesEnvironment = __bind(this._buildExecutesEnvironment, this);
      this._getEnvironmentAddon = __bind(this._getEnvironmentAddon, this);
      this._isReservedIdentifiersUsed = __bind(this._isReservedIdentifiersUsed, this);
      this._getReservedIdentifiersList = __bind(this._getReservedIdentifiersList, this);
      this._setRuntimeEnv = __bind(this._setRuntimeEnv, this);
      this._getRuntimeEnv = __bind(this._getRuntimeEnv, this);
      this._whereResolved = __bind(this._whereResolved, this);
      this.setRuntimeEnv = __bind(this.setRuntimeEnv, this);
      this.getRuntimeEnv = __bind(this.getRuntimeEnv, this);
      this.getRuntimeEnvValue = __bind(this.getRuntimeEnvValue, this);
      this.getFullResolvedList = __bind(this.getFullResolvedList, this);
      this.whereResolved = __bind(this.whereResolved, this);
      this.isCommandExists = __bind(this.isCommandExists, this);
      this.executeSync = __bind(this.executeSync, this);
      this.execute = __bind(this.execute, this);
      this._logger_ = (_ref = options.logger) != null ? _ref : console;
      _ref1 = this._processInCommandObject(in_command_object), this._executes_ = _ref1[0], this._resolved_at_ = _ref1[1];
      this._environment_dict_ = {};
      this._run_environment_ = this._buildExecutesEnvironment(this._executes_);
    }


    /*
    Этот метод (асинхронно) выполняет команду относительно известного ему интерфейса
    
    @params {Boolean}   is_lenient  (optional)  опциональный ключ - если false или отсутствует - выкинет ошибку на неизвестную команду, если true - просто undefined
    @params {String}    command                 команда
    @params {Any}       args        (optional)  аргументы
    @params {Function}  cb                      calback
     */

    BaseExecutor.prototype.execute = function() {
      var args, is_lenient, new_args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _ref = this._separateIsLenient.apply(this, args), is_lenient = _ref[0], new_args = _ref[1];
      return this._executeCommand.apply(this, [is_lenient].concat(__slice.call(new_args)));
    };


    /*
    Этот метод синхронно выполняет команду относительно известного ему интерфейса
    
    @params {Boolean}   is_lenient (optional)   опциональный ключ - если false или отсутствует - выкинет ошибку на неизвестную команду, если true - просто undefined
    @params {String}    command                 команда
    @params {Any}       args        (optional)  аргументы
     */

    BaseExecutor.prototype.executeSync = function() {
      var args, is_lenient, new_args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _ref = this._separateIsLenient.apply(this, args), is_lenient = _ref[0], new_args = _ref[1];
      return this._executeCommandSync.apply(this, [is_lenient].concat(__slice.call(new_args)));
    };


    /*
    Проверяет существует ли такая команада
    
    @params {String} command  имя команды для проверки
     */

    BaseExecutor.prototype.isCommandExists = function(command) {
      return this._isCommandExists(command);
    };


    /*
    Сообщает в какой версии была разрешена команда
    
    @params {String} command  имя команды для проверки
     */

    BaseExecutor.prototype.whereResolved = function(command) {
      return this._whereResolved(command);
    };


    /*
    Возвращает полный список команд с версией, в которой они были разрешены
    (будет полезно для теста)
     */

    BaseExecutor.prototype.getFullResolvedList = function() {
      return this._resolved_at_;
    };


    /*
    Возвращает значение для одного параметра из окружения среды исполнения команды
    (не клонирует, так что изменять их не следует) - подумать на эту тему
    
    @params {String} key ключ по которому нужен параметр
    @return {Mixed}
     */

    BaseExecutor.prototype.getRuntimeEnvValue = function(key) {
      return this._getRuntimeEnv([key])[key];
    };


    /*
    Возвращает объект с параметрами из окружения среды исполнения команды
    (не клонирует, так что изменять их не следует) - подумать на эту тему
    
    @params {Mixed} keys ключ/список ключей/массив со списком ключей
    @return {Object}
     */

    BaseExecutor.prototype.getRuntimeEnv = function() {
      var keys;
      keys = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (_.isArray(keys[0])) {
        keys = keys[0];
      }
      return this._getRuntimeEnv(keys);
    };


    /*
    Устанавливает окружение среды исполнения команды
    
    @param {Object} env_object объект со свойствами среды исполнения
     */

    BaseExecutor.prototype.setRuntimeEnv = function(env_object) {
      this._setRuntimeEnv(env_object);
      return this;
    };


    /*  
          ******  ******  *** *     *    *    ******* ******* 
          *     * *     *  *  *     *   * *      *    *       
          *     * *     *  *  *     *  *   *     *    *       
          ******  ******   *  *     * *     *    *    *****   
          *       *   *    *   *   *  *******    *    *       
          *       *    *   *    * *   *     *    *    *       
          *       *     * ***    *    *     *    *    *******
     */


    /*
    Собщает в какой версии была разрешена команда
     */

    BaseExecutor.prototype._whereResolved = function(command) {
      if (!this._isCommandExists(command)) {
        throw ReferenceError(this._unknownCommandErrorString(command));
      }
      return this._resolved_at_[command];
    };


    /*
    Возвращает объектом все значения
     */

    BaseExecutor.prototype._getRuntimeEnv = function(keys) {
      return _.reduce(keys, (function(acc, key) {
        acc[key] = this._environment_dict_[key];
        return acc;
      }), {}, this);
    };


    /*
    Устанавливает (дополняет) словарь окружения среды исполнения
     */

    BaseExecutor.prototype._setRuntimeEnv = function(new_env_obj) {
      if (!_.isPlainObject(new_env_obj)) {
        throw Error("environment must be plain object, but get |" + new_env_obj + "|");
      }
      return this._environment_dict_ = _.assign(this._environment_dict_, new_env_obj);
    };


    /*
    Возвращает список зарезервиннованных слов
     */

    BaseExecutor.prototype._getReservedIdentifiersList = function() {
      return this._getAddonInjectionsMethodsList();
    };


    /*
    Проверяет нет ли во входящем объекте использования зарезервированных слов
     */

    BaseExecutor.prototype._isReservedIdentifiersUsed = function(in_list) {
      var intersected;
      intersected = _.intersection(in_list, this._getReservedIdentifiersList());
      if (_.isEmpty(intersected)) {
        return null;
      } else {
        return intersected;
      }
    };


    /*
    Список методов, которые будут инжектится в окружение
     */

    BaseExecutor.prototype._getAddonInjectionsMethodsList = function() {
      return ['getRuntimeEnv', 'getRuntimeEnvValue', 'setRuntimeEnv', 'isCommandExists'];
    };


    /*
    Возвращает объект с дополнением для среды окружения, оно будет в него подмешиваться
     */

    BaseExecutor.prototype._getEnvironmentAddon = function() {
      var reduced_fn;
      reduced_fn = function(acc, method_name) {
        acc[method_name] = _.bind(this[method_name], this);
        return acc;
      };
      return _.reduce(this._getAddonInjectionsMethodsList(), reduced_fn, {}, this);
    };


    /*
    Строит окружение для исполняемого кода
    по сути дополняет полученное из файлов ссылкой на методы разрешения значений окружения
     */

    BaseExecutor.prototype._buildExecutesEnvironment = function(executes) {
      return _.assign({}, executes, this._getEnvironmentAddon());
    };


    /*
    Вычлиняет ключ strict-режима из вызова
     */

    BaseExecutor.prototype._separateIsLenient = function() {
      var args, is_lenient;
      is_lenient = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!_.isBoolean(is_lenient)) {
        args.unshift(is_lenient);
        is_lenient = false;
      }
      return [is_lenient, args];
    };


    /*
    Этот метод процессит входящий объект с методами
     */

    BaseExecutor.prototype._processInCommandObject = function(in_command_object) {
      var intersected;
      if (!((in_command_object.executes != null) || (in_command_object.resolved_at != null))) {
        throw Error("command object MUST have keys `executes` and `resolved_at` but get |" + in_command_object + "|");
      }
      if (intersected = this._isReservedIdentifiersUsed(_.keys(in_command_object.executes))) {
        throw Error(this._getReservedIdentifiersErrorText(intersected, in_command_object.resolved_at));
      }
      return [in_command_object.executes, in_command_object.resolved_at];
    };


    /*
    Формирует текст ошибки при использовании зарезервированных слов
     */

    BaseExecutor.prototype._getReservedIdentifiersErrorText = function(intersected, resolved_at) {
      var identifier, words_list;
      words_list = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = intersected.length; _i < _len; _i++) {
          identifier = intersected[_i];
          _results.push("|" + identifier + "| from |" + resolved_at[identifier] + "|");
        }
        return _results;
      })();
      return "reserved identifier used:\n* " + (words_list.join("\n")) + "\nabort!\nfull reserved identifiers list:\n" + (this._getReservedIdentifiersList().join(', '));
    };


    /*
    Внутренний метод, делающий всю работу
     */

    BaseExecutor.prototype._executeCommand = function() {
      var cb, command, is_lenient, options, _base, _i;
      is_lenient = arguments[0], command = arguments[1], options = 4 <= arguments.length ? __slice.call(arguments, 2, _i = arguments.length - 1) : (_i = 2, []), cb = arguments[_i++];
      if (!_.isFunction(cb)) {
        throw TypeError("callback not a function! |" + cb + "|");
      }
      if (!this._isCommandExists(command)) {
        if (is_lenient) {
          if (typeof (_base = this._logger_).warn === "function") {
            _base.warn(this._unknownCommandErrorString(command));
          }
          return cb(null, void 0);
        } else {
          return cb(ReferenceError(this._unknownCommandErrorString(command)));
        }
      }
      return this._executes_[command].apply(this._run_environment_, options.concat(cb));
    };


    /*
    Cинхронный Внутренний метод, делающий всю работу
     */

    BaseExecutor.prototype._executeCommandSync = function() {
      var command, is_lenient, options, _base;
      is_lenient = arguments[0], command = arguments[1], options = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (!this._isCommandExists(command)) {
        if (is_lenient) {
          if (typeof (_base = this._logger_).warn === "function") {
            _base.warn(this._unknownCommandErrorString(command));
          }
          return void 0;
        } else {
          throw ReferenceError(this._unknownCommandErrorString(command));
        }
      }
      return this._executes_[command].apply(this._run_environment_, options);
    };


    /*
    Этот метод вернет нам строку ошибки, что метод нам неизвестен
     */

    BaseExecutor.prototype._unknownCommandErrorString = function(command) {
      return "dont know command |" + command + "|, known list are |" + (_.keys(this._executes_).join(', ')) + "|";
    };


    /*
    Проверка на то, что мы знаем эту команду
     */

    BaseExecutor.prototype._isCommandExists = function(command) {
      return !(this._executes_[command] == null);
    };

    return BaseExecutor;

  })();

}).call(this);
