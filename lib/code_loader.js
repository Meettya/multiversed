// Generated by CoffeeScript 1.7.1

/*
Этот модуль исполняет загруженный текст, возможно используя препроцессор.

Смысл - не хочется использовать require - так как он синхронный, следовательно нужно эмулировать загрузку.
Правда если в самом модуле используется require - толку с этого не так много, как возни, но может быть и с этим что-то придумаем
 */

(function() {
  var CodeLoader,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  module.exports = CodeLoader = (function() {
    function CodeLoader(options) {
      var _ref;
      if (options == null) {
        options = {};
      }
      this.loadCode = __bind(this.loadCode, this);
      this._logger_ = (_ref = options.logger) != null ? _ref : console;
    }


    /*
    Загружает код для одного файла
    пока оставляем синхронный вариант, не будем делать вид что асинхронно выполянется
     */

    CodeLoader.prototype.loadCode = function(full_filename) {
      return this._loadCode(full_filename);
    };


    /*  
          ******  ******  *** *     *    *    ******* ******* 
          *     * *     *  *  *     *   * *      *    *       
          *     * *     *  *  *     *  *   *     *    *       
          ******  ******   *  *     * *     *    *    *****   
          *       *   *    *   *   *  *******    *    *       
          *       *    *   *    * *   *     *    *    *       
          *       *     * ***    *    *     *    *    *******
     */


    /*
    Сама команда
     */

    CodeLoader.prototype._loadCode = function(full_filename) {

      /*
      Да, все вот так банально и синхронно
      ЧИТАТЬ ДАЛЬНЕЙШЕЕ ПЕРЕД НЕГОДОВАНИЕМ ОБЯЗАТЕЛЬНО!!!
      
      причина - ну прочитаем вы асинхронно указанный файл,
      начнем парсить - а там require и...? смысл в наших асинхронах?
      кроме того - используя собственный эмулятор require мы лишаем системный кеша этого файла,
      а он вполне может быть кем-то запрошен - т.е. по факту больше вреда чем пользы
      
      идея с РЕКУРСИВНОЙ подменой require и правкой исходников с заворачиванием их в асинхронные колбеки кажется безумной
      
      есть правда идея попробовать Clinch натравить на файлы - 
      но это для домашних экспериментов, возможно что-то из этого выгорит, попробовать (собственно, почему нет)
      
      Позднее посмотреть вот это на предмет асинхронной загрузки
      TODO @meettya http://stackoverflow.com/questions/13917420/node-js-load-module-async
      TODO @meettya https://github.com/webpack/enhanced-require/blob/master/lib/execModule.js
      
      а пока вот так
       */
      return require(full_filename);
    };

    return CodeLoader;

  })();

}).call(this);
