// Generated by CoffeeScript 1.9.3

/*
Это стек продуктов, в каждом из которых имеется свой собственный стек версий

пока не совсем понятно какое api будет удачнее: 
 - buildVersion('product', 'version')
 - getProduct('product').buildVersion('version')

наверное все же композитное, но обсуждаемо
 */

(function() {
  var ProductsSearcher, ProductsStack, VersionsStack, _, async, fs, path,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('lodash');

  async = require('async');

  fs = require('fs');

  path = require('path');

  VersionsStack = require('./versions_stack');

  ProductsSearcher = require('./products_searcher');

  module.exports = ProductsStack = (function() {
    function ProductsStack(options) {
      var ref, ref1;
      if (options == null) {
        options = {};
      }
      this._unknownProductNotify = bind(this._unknownProductNotify, this);
      this._getProduct = bind(this._getProduct, this);
      this._getVersionsStackAllProducts = bind(this._getVersionsStackAllProducts, this);
      this._initStack = bind(this._initStack, this);
      this.getProduct = bind(this.getProduct, this);
      this.initStack = bind(this.initStack, this);
      this._logger_ = (ref = options.logger) != null ? ref : console;
      this._is_strict_ = (ref1 = options.strict) != null ? ref1 : false;
      this._products_searcher_ = new ProductsSearcher({
        logger: this._logger_
      });
      this._is_inited_ = false;
      this._products_dict_ = {};
      this._current_dir_ = null;
    }


    /*
    Инициация стека для сбора исходников
     */

    ProductsStack.prototype.initStack = function(dir, main_cb) {
      return this._initStack(dir, main_cb);
    };


    /*
    Возвращает запрошенный продукт
     */

    ProductsStack.prototype.getProduct = function(product) {
      return this._getProduct(product);
    };


    /*  
          ******  ******  *** *     *    *    ******* ******* 
          *     * *     *  *  *     *   * *      *    *       
          *     * *     *  *  *     *  *   *     *    *       
          ******  ******   *  *     * *     *    *    *****   
          *       *   *    *   *   *  *******    *    *       
          *       *    *   *    * *   *     *    *    *       
          *       *     * ***    *    *     *    *    *******
     */


    /*
    Инициализатор
     */

    ProductsStack.prototype._initStack = function(dir, main_cb) {
      if (this._is_inited_) {
        return main_cb(Error("already inited with dir |" + this._current_dir_ + "|, abort!"));
      }
      this._is_inited_ = true;
      this._current_dir_ = dir;
      return async.waterfall([
        (function(_this) {
          return function(acb) {
            return _this._products_searcher_.proceedDirectory(dir, acb);
          };
        })(this), (function(_this) {
          return function(products, acb) {
            return _this._getVersionsStackAllProducts(dir, products, acb);
          };
        })(this)
      ], (function(_this) {
        return function(err, stacks) {
          if (err != null) {
            return main_cb(err);
          }
          _this._products_dict_ = stacks;
          return main_cb(null, _this);
        };
      })(this));
    };


    /*
    Создает стеки версий для каждого переданного продукта
    
    Кстати, возможно сюда и следует впилить фильтр, чтобы два раза не парсить директории
    Позднее подумать
     */

    ProductsStack.prototype._getVersionsStackAllProducts = function(root_dir, products, cb) {
      var init_fn;
      init_fn = (function(_this) {
        return function(product, acb) {
          var versions_stack;
          versions_stack = new VersionsStack({
            logger: _this._logger_
          });
          return versions_stack.initStack(path.join(root_dir, product), acb);
        };
      })(this);
      return async.map(products, init_fn, (function(_this) {
        return function(err, versions) {
          if (err != null) {
            return cb(err);
          }
          return cb(null, _.zipObject(products, versions));
        };
      })(this));
    };


    /*
    Возвращает стек версий для запрошенного продукта
     */

    ProductsStack.prototype._getProduct = function(product) {
      var result;
      if (!this._is_inited_) {
        throw Error("init object first, aborted!");
      }
      if (!(result = this._products_dict_[product])) {
        throw Error(this._unknownProductNotify(product));
      }
      return result;
    };


    /*
    Обрабатываем ситуацию когда у нас хотят продукт о котором мы не знаем
     */

    ProductsStack.prototype._unknownProductNotify = function(product) {
      return "unknown product |" + product + "|, not listed in directory |" + this._current_dir_ + "|\nknown product list:\n|" + (_.keys(this._products_dict_).join(', ')) + "|";
    };

    return ProductsStack;

  })();

}).call(this);
